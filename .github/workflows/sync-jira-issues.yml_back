name: Sync GitHub Issues with Jira

on:
  issues:
    types: [opened, edited, closed, reopened, labeled, unlabeled, assigned, unassigned]
  issue_comment:
    types: [created, edited, deleted]
  workflow_dispatch:
    inputs:
      action_type:
        description: 'Choose what to do'
        required: true
        type: choice
        default: 'sync-issue'
        options:
        - sync-issue
        - sync-all-issues
        - update-ticket-types
        - sync-statuses-only
      issue_number:
        description: 'Specific GitHub issue number to sync (leave empty for all in sync-all-issues)'
        required: false
        type: string

jobs:
  jira-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Sync to Jira using REST APIs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { issue } = context.payload;
            const actionType = '${{ github.event.inputs.action_type }}' || 'sync-issue';
            const issueNumber = '${{ github.event.inputs.issue_number }}';

            console.log(`Action type: ${actionType}`);
            console.log(`Issue number: ${issueNumber}`);

            if (actionType === 'update-ticket-types') {
              await updateTicketTypes();
            } else if (actionType === 'sync-statuses-only') {
              await syncStatusesOnly(issueNumber);
            } else if (actionType === 'sync-all-issues') {
              await syncAllIssues(issueNumber);
            } else {
              // Handle manual single issue sync or automatic trigger
              if (context.eventName === 'workflow_dispatch' && issueNumber) {
                const { data: specificIssue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                await syncIssueToJira(specificIssue);
              } else if (issue && !issue.pull_request) {
                await syncIssueToJira(issue);
              }
            }

            async function syncAllIssues(specificIssueNumber) {
              const issues = await github.paginate(github.rest.issues.listForRepo, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all'
              });
              
              let syncedCount = 0;
              for (const iss of issues) {
                // Skip pull requests
                if (!iss.pull_request) {
                  // If specific issue number provided, only sync that one
                  if (!specificIssueNumber || specificIssueNumber === '' || String(iss.number) === specificIssueNumber) {
                    await syncIssueToJira(iss);
                    syncedCount++;
                  }
                }
              }
              console.log(`âœ… Synced ${syncedCount} issues to Jira`);
            }

            async function syncStatusesOnly(specificIssueNumber) {
              console.log('Starting status synchronization...');
              
              const jiraConfig = {
                host: '${{ secrets.JIRA_HOST }}',
                email: '${{ secrets.JIRA_USER_EMAIL }}',
                apiToken: '${{ secrets.JIRA_API_TOKEN }}',
                projectKey: 'RLM'
              };

              const issues = await github.paginate(github.rest.issues.listForRepo, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all'
              });
              
              let updatedCount = 0;
              let errorCount = 0;

              for (const githubIssue of issues) {
                // Skip pull requests
                if (githubIssue.pull_request) continue;
                
                // If specific issue number provided, only sync that one
                if (specificIssueNumber && specificIssueNumber !== '' && String(githubIssue.number) !== specificIssueNumber) {
                  continue;
                }

                try {
                  // Search for corresponding Jira issue
                  const searchResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/search?jql=project=RLM AND summary ~ "\\\\[GitHub\\\\] #${githubIssue.number}"`, {
                    method: 'GET',
                    headers: {
                      'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                      'Content-Type': 'application/json',
                    },
                  });

                  if (!searchResponse.ok) {
                    console.error(`âŒ Failed to search for issue #${githubIssue.number}`);
                    continue;
                  }

                  const searchResults = await searchResponse.json();
                  
                  if (searchResults.issues.length === 0) {
                    console.log(`âš ï¸ No Jira issue found for GitHub issue #${githubIssue.number}`);
                    continue;
                  }

                  const jiraIssue = searchResults.issues[0];
                  await updateJiraIssueStatus(jiraIssue.key, githubIssue, jiraConfig);
                  updatedCount++;

                  // Small delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 500));
                  
                } catch (error) {
                  console.error(`âŒ Error syncing status for issue #${githubIssue.number}:`, error.message);
                  errorCount++;
                }
              }

              console.log(`ðŸŽ‰ Status sync completed! Updated: ${updatedCount}, Errors: ${errorCount}`);
            }

            async function updateJiraIssueStatus(jiraIssueKey, githubIssue, jiraConfig) {
              console.log(`Updating status for ${jiraIssueKey} based on GitHub issue #${githubIssue.number}`);

              // Map GitHub state and labels to Jira statuses based on your workflow
              let targetStatusName = mapGitHubToJiraStatus(githubIssue);
              
              // Get available transitions for this issue
              const transitionsResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/${jiraIssueKey}/transitions`, {
                method: 'GET',
                headers: {
                  'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                },
              });

              if (!transitionsResponse.ok) {
                console.error(`âŒ Failed to get transitions for ${jiraIssueKey}`);
                return;
              }

              const transitionsData = await transitionsResponse.json();
              const transitions = transitionsData.transitions;
              
              // Find the transition that leads to our target status
              const targetTransition = findMatchingTransition(transitions, targetStatusName);

              if (targetTransition) {
                // Perform the transition
                const transitionResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/${jiraIssueKey}/transitions`, {
                  method: 'POST',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    transition: {
                      id: targetTransition.id
                    }
                  })
                });

                if (transitionResponse.ok) {
                  console.log(`âœ… Updated ${jiraIssueKey} status to: ${targetStatusName}`);
                } else {
                  const errorText = await transitionResponse.text();
                  console.error(`âŒ Failed to transition ${jiraIssueKey}:`, errorText);
                }
              } else {
                console.log(`âš ï¸ No transition found to status "${targetStatusName}" for ${jiraIssueKey}`);
                console.log(`Available transitions: ${transitions.map(t => t.to.name).join(', ')}`);
              }

              // Update labels
              await updateJiraLabels(jiraIssueKey, githubIssue.labels, jiraConfig);

              // Sync assignee if present
              if (githubIssue.assignee) {
                await syncAssignee(jiraIssueKey, githubIssue.assignee, jiraConfig);
              }
            }

            function mapGitHubToJiraStatus(githubIssue) {
              // Map based on your workflow diagram
              if (githubIssue.state === 'closed') {
                // Check for specific closed reasons via labels
                if (githubIssue.labels?.some(label => 
                  label.name === 'wontfix' || label.name === 'duplicate' || label.name === 'invalid'
                )) {
                  return 'SOLUTION DENIED';
                }
                return 'RESOLVED';
              }
              
              if (githubIssue.state === 'open') {
                // New issues start in NEW
                if (!githubIssue.assignee && !hasActivity(githubIssue)) {
                  return 'NEW';
                }
                
                // Issues with assignee but no specific labels go to IN PROGRESS
                if (githubIssue.assignee) {
                  return 'IN PROGRESS';
                }
                
                // Issues with specific labels
                if (githubIssue.labels?.some(label => label.name === 'bug')) {
                  return 'IN PROGRESS';
                }
                if (githubIssue.labels?.some(label => label.name === 'enhancement')) {
                  return 'IN SPECIFICATION';
                }
                if (githubIssue.labels?.some(label => label.name === 'question')) {
                  return 'PENDING';
                }
                
                return 'NEW';
              }
              
              return 'NEW'; // Default for reopened or other states
            }

            function hasActivity(githubIssue) {
              // Check if issue has comments or has been updated recently
              // This is a simple check - you might want to enhance this
              return githubIssue.comments > 0 || 
                     (new Date() - new Date(githubIssue.updated_at)) < (24 * 60 * 60 * 1000); // Updated in last 24h
            }

            function findMatchingTransition(transitions, targetStatusName) {
              const statusVariations = {
                'NEW': ['new', 'to do', 'open'],
                'IN SPECIFICATION': ['in specification', 'specification', 'analysis'],
                'IN PROGRESS': ['in progress', 'progress', 'started', 'active'],
                'PENDING': ['pending', 'on hold', 'hold', 'waiting'],
                'IN REVIEW': ['in review', 'review', 'testing'],
                'SOLUTION DENIED': ['solution denied', 'denied', 'rejected', 'wontfix'],
                'RESOLVED': ['resolved', 'done', 'completed', 'closed']
              };

              for (const [status, variations] of Object.entries(statusVariations)) {
                if (status === targetStatusName) {
                  return transitions.find(t => 
                    variations.some(variation => t.to.name.toLowerCase().includes(variation.toLowerCase()))
                  );
                }
              }
              
              return transitions[0]; // Fallback to first available transition
            }

            async function updateJiraLabels(jiraIssueKey, githubLabels, jiraConfig) {
              if (!githubLabels || githubLabels.length === 0) return;

              const labelMapping = {
                'Backend': 'backend',
                'bug': 'bug',
                'Docker': 'docker',
                'documentation': 'documentation',
                'duplicate': 'duplicate',
                'enhancement': 'enhancement',
                'EPIC': 'epic',
                'Frontend': 'frontend',
                'good first issue': 'good-first-issue',
                'help wanted': 'help-wanted',
                'invalid': 'invalid',
                'Python': 'python',
                'question': 'question',
                'wontfix': 'wontfix'
              };

              const jiraLabels = githubLabels
                .map(label => labelMapping[label.name] || label.name.toLowerCase().replace(/\s+/g, '-'))
                .filter(label => label.length > 0);

              if (jiraLabels.length === 0) return;

              try {
                const updateResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/${jiraIssueKey}`, {
                  method: 'PUT',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    fields: {
                      labels: jiraLabels
                    }
                  })
                });

                if (updateResponse.ok) {
                  console.log(`âœ… Updated labels for ${jiraIssueKey}: ${jiraLabels.join(', ')}`);
                } else {
                  console.log(`âš ï¸ Could not update labels for ${jiraIssueKey}`);
                }
              } catch (error) {
                console.error(`âŒ Error updating labels for ${jiraIssueKey}:`, error.message);
              }
            }

            async function syncAssignee(jiraIssueKey, githubAssignee, jiraConfig) {
              try {
                console.log(`Attempting to assign ${jiraIssueKey} to ${githubAssignee.login}`);
                // Assignee sync would go here - requires Jira account mapping
                console.log(`âš ï¸ Assignee sync requires manual mapping setup for user: ${githubAssignee.login}`);
              } catch (error) {
                console.error(`âŒ Error syncing assignee for ${jiraIssueKey}:`, error.message);
              }
            }

            async function updateTicketTypes() {
              console.log('Starting bulk update of ticket types...');
              
              const jiraConfig = {
                host: '${{ secrets.JIRA_HOST }}',
                email: '${{ secrets.JIRA_USER_EMAIL }}',
                apiToken: '${{ secrets.JIRA_API_TOKEN }}',
                projectKey: 'RLM'
              };

              // First, get the target issue type (Task, Story, Bug, etc.)
              const issueTypesResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/createmeta?projectKeys=${jiraConfig.projectKey}&expand=projects.issuetypes`, {
                method: 'GET',
                headers: {
                  'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                  'Content-Type': 'application/json',
                },
              });

              if (!issueTypesResponse.ok) {
                const errorText = await issueTypesResponse.text();
                console.error('âŒ Failed to fetch Jira issue types:', errorText);
                return;
              }

              const metaData = await issueTypesResponse.json();
              const project = metaData.projects[0];
              const issueTypes = project.issuetypes;
              
              // Find appropriate issue type (Task, Story, Bug, etc.)
              const targetType = issueTypes.find(it => 
                it.name === 'Task' || it.name === 'Story' || it.name === 'Bug'
              ) || issueTypes[0];

              if (!targetType) {
                console.error('âŒ Suitable issue type not found in project');
                console.log('Available issue types:', issueTypes.map(it => it.name));
                return;
              }

              console.log(`Found target issue type: ${targetType.name}`);

              // Search for issues with "[GitHub]" in summary
              const searchResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/search?jql=project=RLM AND summary ~ "\\\\[GitHub\\\\]" AND issuetype != "${targetType.name}"&maxResults=100`, {
                method: 'GET',
                headers: {
                  'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                  'Content-Type': 'application/json',
                },
              });

              if (!searchResponse.ok) {
                const errorText = await searchResponse.text();
                console.error('âŒ Failed to search Jira issues:', errorText);
                return;
              }

              const searchResults = await searchResponse.json();
              console.log(`Found ${searchResults.total} issues to update`);

              let updatedCount = 0;
              let errorCount = 0;

              for (const jiraIssue of searchResults.issues) {
                try {
                  // Update the issue type
                  const updateResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/${jiraIssue.key}`, {
                    method: 'PUT',
                    headers: {
                      'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                      fields: {
                        issuetype: {
                          id: targetType.id,
                          name: targetType.name
                        }
                      }
                    })
                  });

                  if (updateResponse.ok) {
                    console.log(`âœ… Updated ${jiraIssue.key} to ${targetType.name}`);
                    updatedCount++;
                  } else {
                    const errorText = await updateResponse.text();
                    console.error(`âŒ Failed to update ${jiraIssue.key}:`, errorText);
                    errorCount++;
                  }

                  // Small delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 100));
                  
                } catch (error) {
                  console.error(`âŒ Error updating ${jiraIssue.key}:`, error.message);
                  errorCount++;
                }
              }

              console.log(`ðŸŽ‰ Bulk update completed! Updated: ${updatedCount}, Errors: ${errorCount}`);
            }

            async function syncIssueToJira(issue) {
              console.log(`Syncing issue #${issue.number} to Jira: ${issue.title}`);
              
              const jiraConfig = {
                host: '${{ secrets.JIRA_HOST }}',
                email: '${{ secrets.JIRA_USER_EMAIL }}',
                apiToken: '${{ secrets.JIRA_API_TOKEN }}',
                projectKey: 'RLM'
              };

              try {
                // First, check if this issue already exists in Jira
                const existingIssue = await findExistingJiraIssue(issue.number, jiraConfig);
                
                if (existingIssue) {
                  console.log(`ðŸ”„ Updating existing Jira issue: ${existingIssue.key}`);
                  await updateJiraIssueStatus(existingIssue.key, issue, jiraConfig);
                  return existingIssue;
                }

                // Get available issue types
                const issueTypesResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/createmeta?projectKeys=${jiraConfig.projectKey}&expand=projects.issuetypes`, {
                  method: 'GET',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                });

                if (!issueTypesResponse.ok) {
                  const errorText = await issueTypesResponse.text();
                  console.error('âŒ Failed to fetch Jira issue types:', errorText);
                  return;
                }

                const metaData = await issueTypesResponse.json();
                const project = metaData.projects[0];
                const issueTypes = project.issuetypes;
                
                // Map GitHub labels to Jira issue types
                const issueTypeFromLabels = mapLabelsToIssueType(issue.labels, issueTypes);
                const selectedIssueType = issueTypeFromLabels || getDefaultIssueType(issueTypes);

                // Create Jira issue with GitHub issue number in summary for easier tracking
                const jiraResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue`, {
                  method: 'POST',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    fields: {
                      project: {
                        key: jiraConfig.projectKey
                      },
                      summary: `[GitHub] #${issue.number} - ${issue.title}`,
                      description: `${issue.body || 'No description provided'}\n\n---\n**GitHub Issue:** ${issue.html_url}`,
                      issuetype: {
                        id: selectedIssueType.id,
                        name: selectedIssueType.name
                      }
                    }
                  })
                });

                if (jiraResponse.ok) {
                  const jiraIssue = await jiraResponse.json();
                  console.log(`âœ… Created Jira issue: ${jiraIssue.key}`);
                  
                  // Now update the status and labels based on GitHub issue
                  await updateJiraIssueStatus(jiraIssue.key, issue, jiraConfig);
                  
                  console.log(`ðŸ”— Jira URL: https://${jiraConfig.host}/browse/${jiraIssue.key}`);
                  
                  // Try to add comment to GitHub issue
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `ðŸ”— Synced to Jira: https://${jiraConfig.host}/browse/${jiraIssue.key}`
                    });
                  } catch (commentError) {
                    console.log('âš ï¸ Could not add comment to GitHub issue, but Jira sync was successful');
                  }
                  
                  return jiraIssue;
                } else {
                  const errorText = await jiraResponse.text();
                  console.error('âŒ Jira API error:', jiraResponse.status, errorText);
                  
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `âŒ Failed to sync to Jira: ${jiraResponse.status} - ${errorText}`
                    });
                  } catch (commentError) {
                    console.log('âš ï¸ Could not add error comment to GitHub issue');
                  }
                }
              } catch (error) {
                console.error('âŒ Unexpected error:', error.message);
                
                try {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `âŒ Error syncing to Jira: ${error.message}`
                  });
                } catch (commentError) {
                  console.log('âš ï¸ Could not add error comment to GitHub issue');
                }
              }
            }

            function mapLabelsToIssueType(githubLabels, availableIssueTypes) {
              if (!githubLabels) return null;
              
              const labelToTypeMapping = {
                'bug': 'Bug',
                'enhancement': 'Story',
                'EPIC': 'Epic',
                'documentation': 'Task',
                'question': 'Task'
              };

              for (const label of githubLabels) {
                const issueTypeName = labelToTypeMapping[label.name];
                if (issueTypeName) {
                  const issueType = availableIssueTypes.find(it => 
                    it.name.toLowerCase() === issueTypeName.toLowerCase()
                  );
                  if (issueType) {
                    console.log(`ðŸŽ¯ Using issue type "${issueType.name}" based on label "${label.name}"`);
                    return issueType;
                  }
                }
              }
              return null;
            }

            function getDefaultIssueType(issueTypes) {
              const preferredTypes = ['Task', 'Story', 'Bug', 'Sub-task'];
              
              for (const typeName of preferredTypes) {
                const issueType = issueTypes.find(it => it.name === typeName);
                if (issueType) {
                  console.log(`Using preferred issue type: ${issueType.name}`);
                  return issueType;
                }
              }
              
              // Fallback to first non-service-desk type
              const nonServiceDeskTypes = issueTypes.filter(it => 
                !it.name.includes('Service') && 
                !it.name.includes('Request') &&
                !it.name.toLowerCase().includes('email')
              );
              const fallbackType = nonServiceDeskTypes[0] || issueTypes[0];
              console.log(`Using fallback issue type: ${fallbackType.name}`);
              return fallbackType;
            }

            async function findExistingJiraIssue(githubIssueNumber, jiraConfig) {
              try {
                const searchResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/search?jql=project=RLM AND summary ~ "\\\\[GitHub\\\\] #${githubIssueNumber}"`, {
                  method: 'GET',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                });

                if (searchResponse.ok) {
                  const searchResults = await searchResponse.json();
                  return searchResults.issues.length > 0 ? searchResults.issues[0] : null;
                }
              } catch (error) {
                console.error('Error searching for existing Jira issue:', error.message);
              }
              return null;
            }
  
