name: Sync GitHub Issues with Jira

on:
  issues:
    types: [opened, edited, closed, reopened, labeled, unlabeled, assigned, unassigned]
  issue_comment:
    types: [created, edited, deleted]
  workflow_dispatch:
    inputs:
      action_type:
        description: 'Choose what to do'
        required: true
        type: choice
        default: 'sync-issue'
        options:
        - sync-issue
        - sync-all-issues
        - update-ticket-types
        - sync-statuses-only
      issue_number:
        description: 'Specific GitHub issue number to sync (leave empty for all in sync-all-issues)'
        required: false
        type: string

jobs:
  jira-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Sync to Jira using REST APIs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { issue } = context.payload;
            const actionType = '${{ github.event.inputs.action_type }}' || 'sync-issue';
            const issueNumber = '${{ github.event.inputs.issue_number }}';

            console.log(`Action type: ${actionType}`);
            console.log(`Issue number: ${issueNumber}`);

            if (actionType === 'update-ticket-types') {
              await updateTicketTypes();
            } else if (actionType === 'sync-statuses-only') {
              await syncStatusesOnly(issueNumber);
            } else if (actionType === 'sync-all-issues') {
              await syncAllIssues(issueNumber);
            } else {
              // Handle manual single issue sync or automatic trigger
              if (context.eventName === 'workflow_dispatch' && issueNumber) {
                const { data: specificIssue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                await syncIssueToJira(specificIssue);
              } else if (issue && !issue.pull_request) {
                await syncIssueToJira(issue);
              }
            }

            async function syncAllIssues(specificIssueNumber) {
              const issues = await github.paginate(github.rest.issues.listForRepo, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all'
              });
              
              let syncedCount = 0;
              for (const iss of issues) {
                // Skip pull requests
                if (!iss.pull_request) {
                  // If specific issue number provided, only sync that one
                  if (!specificIssueNumber || specificIssueNumber === '' || String(iss.number) === specificIssueNumber) {
                    await syncIssueToJira(iss);
                    syncedCount++;
                  }
                }
              }
              console.log(`âœ… Synced ${syncedCount} issues to Jira`);
            }

            async function syncStatusesOnly(specificIssueNumber) {
              console.log('Starting status synchronization...');
              
              const jiraConfig = {
                host: '${{ secrets.JIRA_HOST }}',
                email: '${{ secrets.JIRA_USER_EMAIL }}',
                apiToken: '${{ secrets.JIRA_API_TOKEN }}',
                projectKey: 'RLM'
              };

              const issues = await github.paginate(github.rest.issues.listForRepo, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all'
              });
              
              let updatedCount = 0;
              let errorCount = 0;

              for (const githubIssue of issues) {
                // Skip pull requests
                if (githubIssue.pull_request) continue;
                
                // If specific issue number provided, only sync that one
                if (specificIssueNumber && specificIssueNumber !== '' && String(githubIssue.number) !== specificIssueNumber) {
                  continue;
                }

                try {
                  // Search for corresponding Jira issue
                  const searchResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/search?jql=project=RLM AND summary ~ "\\\\[GitHub\\\\] #${githubIssue.number}"`, {
                    method: 'GET',
                    headers: {
                      'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                      'Content-Type': 'application/json',
                    },
                  });

                  if (!searchResponse.ok) {
                    console.error(`âŒ Failed to search for issue #${githubIssue.number}`);
                    continue;
                  }

                  const searchResults = await searchResponse.json();
                  
                  if (searchResults.issues.length === 0) {
                    console.log(`âš ï¸ No Jira issue found for GitHub issue #${githubIssue.number}`);
                    continue;
                  }

                  const jiraIssue = searchResults.issues[0];
                  await updateJiraIssueStatus(jiraIssue.key, githubIssue, jiraConfig);
                  updatedCount++;

                  // Small delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 500));
                  
                } catch (error) {
                  console.error(`âŒ Error syncing status for issue #${githubIssue.number}:`, error.message);
                  errorCount++;
                }
              }

              console.log(`ðŸŽ‰ Status sync completed! Updated: ${updatedCount}, Errors: ${errorCount}`);
            }

            async function updateJiraIssueStatus(jiraIssueKey, githubIssue, jiraConfig) {
              console.log(`Updating status for ${jiraIssueKey} based on GitHub issue #${githubIssue.number}`);

              // Map GitHub state to Jira status
              const statusMap = {
                'open': 'To Do',
                'closed': 'Done',
                'reopened': 'To Do'
              };

              const targetStatusName = statusMap[githubIssue.state] || 'To Do';
              
              // Get available transitions for this issue
              const transitionsResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/${jiraIssueKey}/transitions`, {
                method: 'GET',
                headers: {
                  'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                },
              });

              if (!transitionsResponse.ok) {
                console.error(`âŒ Failed to get transitions for ${jiraIssueKey}`);
                return;
              }

              const transitionsData = await transitionsResponse.json();
              const transitions = transitionsData.transitions;
              
              // Find the transition that leads to our target status
              const targetTransition = transitions.find(t => 
                t.to.name.toLowerCase() === targetStatusName.toLowerCase() ||
                (targetStatusName === 'Done' && t.to.name.toLowerCase().includes('done')) ||
                (targetStatusName === 'To Do' && (t.to.name.toLowerCase().includes('to do') || t.to.name.toLowerCase().includes('open')))
              );

              if (targetTransition) {
                // Perform the transition
                const transitionResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/${jiraIssueKey}/transitions`, {
                  method: 'POST',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    transition: {
                      id: targetTransition.id
                    }
                  })
                });

                if (transitionResponse.ok) {
                  console.log(`âœ… Updated ${jiraIssueKey} status to: ${targetStatusName}`);
                } else {
                  const errorText = await transitionResponse.text();
                  console.error(`âŒ Failed to transition ${jiraIssueKey}:`, errorText);
                }
              } else {
                console.log(`âš ï¸ No transition found to status "${targetStatusName}" for ${jiraIssueKey}`);
                console.log(`Available transitions: ${transitions.map(t => t.to.name).join(', ')}`);
              }

              // Sync assignee if present
              if (githubIssue.assignee) {
                await syncAssignee(jiraIssueKey, githubIssue.assignee, jiraConfig);
              }
            }

            async function syncAssignee(jiraIssueKey, githubAssignee, jiraConfig) {
              try {
                // Map GitHub username to Jira account ID (this might need adjustment)
                // For now, we'll try to assign by email or leave unassigned if we can't map
                console.log(`Attempting to assign ${jiraIssueKey} to ${githubAssignee.login}`);
                
                // Note: This requires knowing the Jira account ID for the GitHub user
                // You might need to create a mapping or use email addresses
                // For now, we'll log it but skip actual assignment
                console.log(`âš ï¸ Assignee sync requires manual mapping setup for user: ${githubAssignee.login}`);
                
              } catch (error) {
                console.error(`âŒ Error syncing assignee for ${jiraIssueKey}:`, error.message);
              }
            }

            // ... (keep the existing updateTicketTypes function exactly as before)

            async function syncIssueToJira(issue) {
              console.log(`Syncing issue #${issue.number} to Jira: ${issue.title}`);
              
              const jiraConfig = {
                host: '${{ secrets.JIRA_HOST }}',
                email: '${{ secrets.JIRA_USER_EMAIL }}',
                apiToken: '${{ secrets.JIRA_API_TOKEN }}',
                projectKey: 'RLM'
              };

              try {
                // First, check if this issue already exists in Jira
                const existingIssue = await findExistingJiraIssue(issue.number, jiraConfig);
                
                if (existingIssue) {
                  console.log(`ðŸ”„ Updating existing Jira issue: ${existingIssue.key}`);
                  await updateJiraIssueStatus(existingIssue.key, issue, jiraConfig);
                  return existingIssue;
                }

                // Get available issue types
                const issueTypesResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/createmeta?projectKeys=${jiraConfig.projectKey}&expand=projects.issuetypes`, {
                  method: 'GET',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                });

                if (!issueTypesResponse.ok) {
                  const errorText = await issueTypesResponse.text();
                  console.error('âŒ Failed to fetch Jira issue types:', errorText);
                  return;
                }

                const metaData = await issueTypesResponse.json();
                const project = metaData.projects[0];
                const issueTypes = project.issuetypes;
                
                // Prefer standard issue types over Service Desk types
                const preferredTypes = ['Incident', 'Task', 'Story', 'Bug', 'Sub-task'];
                let selectedIssueType = null;
                
                // Try to find a preferred type (Incident first, then others)
                for (const typeName of preferredTypes) {
                  selectedIssueType = issueTypes.find(it => it.name === typeName);
                  if (selectedIssueType) {
                    console.log(`Using preferred issue type: ${selectedIssueType.name}`);
                    break;
                  }
                }
                
                // If no preferred type found, use first non-service-desk type
                if (!selectedIssueType) {
                  const nonServiceDeskTypes = issueTypes.filter(it => 
                    !it.name.includes('Service') && 
                    !it.name.includes('Request') &&
                    !it.name.toLowerCase().includes('email')
                  );
                  selectedIssueType = nonServiceDeskTypes[0] || issueTypes[0];
                  console.log(`Using fallback issue type: ${selectedIssueType.name}`);
                }

                // Create Jira issue with GitHub issue number in summary for easier tracking
                const jiraResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue`, {
                  method: 'POST',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    fields: {
                      project: {
                        key: jiraConfig.projectKey
                      },
                      summary: `[GitHub] #${issue.number} - ${issue.title}`,
                      description: `${issue.body || 'No description provided'}\n\n---\n**GitHub Issue:** ${issue.html_url}`,
                      issuetype: {
                        id: selectedIssueType.id,
                        name: selectedIssueType.name
                      }
                    }
                  })
                });

                if (jiraResponse.ok) {
                  const jiraIssue = await jiraResponse.json();
                  console.log(`âœ… Created Jira issue: ${jiraIssue.key}`);
                  
                  // Now update the status based on GitHub issue state
                  await updateJiraIssueStatus(jiraIssue.key, issue, jiraConfig);
                  
                  console.log(`ðŸ”— Jira URL: https://${jiraConfig.host}/browse/${jiraIssue.key}`);
                  
                  // Try to add comment to GitHub issue
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `ðŸ”— Synced to Jira: https://${jiraConfig.host}/browse/${jiraIssue.key}`
                    });
                  } catch (commentError) {
                    console.log('âš ï¸ Could not add comment to GitHub issue, but Jira sync was successful');
                  }
                  
                  return jiraIssue;
                } else {
                  const errorText = await jiraResponse.text();
                  console.error('âŒ Jira API error:', jiraResponse.status, errorText);
                  
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `âŒ Failed to sync to Jira: ${jiraResponse.status} - ${errorText}`
                    });
                  } catch (commentError) {
                    console.log('âš ï¸ Could not add error comment to GitHub issue');
                  }
                }
              } catch (error) {
                console.error('âŒ Unexpected error:', error.message);
                
                try {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `âŒ Error syncing to Jira: ${error.message}`
                  });
                } catch (commentError) {
                  console.log('âš ï¸ Could not add error comment to GitHub issue');
                }
              }
            }

            async function findExistingJiraIssue(githubIssueNumber, jiraConfig) {
              try {
                const searchResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/search?jql=project=RLM AND summary ~ "\\\\[GitHub\\\\] #${githubIssueNumber}"`, {
                  method: 'GET',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                });

                if (searchResponse.ok) {
                  const searchResults = await searchResponse.json();
                  return searchResults.issues.length > 0 ? searchResults.issues[0] : null;
                }
              } catch (error) {
                console.error('Error searching for existing Jira issue:', error.message);
              }
              return null;
            }

            // ... (keep the existing updateTicketTypes function exactly as you had it before)
            // ... (keep the existing updateTicketTypes function exactly as before)

            async function syncIssueToJira(issue) {
              console.log(`Syncing issue #${issue.number} to Jira: ${issue.title}`);
              
              const jiraConfig = {
                host: '${{ secrets.JIRA_HOST }}',
                email: '${{ secrets.JIRA_USER_EMAIL }}',
                apiToken: '${{ secrets.JIRA_API_TOKEN }}',
                projectKey: 'RLM'
              };

              try {
                // First, check if this issue already exists in Jira
                const existingIssue = await findExistingJiraIssue(issue.number, jiraConfig);
                
                if (existingIssue) {
                  console.log(`ðŸ”„ Updating existing Jira issue: ${existingIssue.key}`);
                  await updateJiraIssueStatus(existingIssue.key, issue, jiraConfig);
                  return existingIssue;
                }

                // Get available issue types
                const issueTypesResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue/createmeta?projectKeys=${jiraConfig.projectKey}&expand=projects.issuetypes`, {
                  method: 'GET',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                });

                if (!issueTypesResponse.ok) {
                  const errorText = await issueTypesResponse.text();
                  console.error('âŒ Failed to fetch Jira issue types:', errorText);
                  return;
                }

                const metaData = await issueTypesResponse.json();
                const project = metaData.projects[0];
                const issueTypes = project.issuetypes;
                
                // Prefer standard issue types over Service Desk types
                const preferredTypes = ['Incident', 'Task', 'Story', 'Bug', 'Sub-task'];
                let selectedIssueType = null;
                
                // Try to find a preferred type (Incident first, then others)
                for (const typeName of preferredTypes) {
                  selectedIssueType = issueTypes.find(it => it.name === typeName);
                  if (selectedIssueType) {
                    console.log(`Using preferred issue type: ${selectedIssueType.name}`);
                    break;
                  }
                }
                
                // If no preferred type found, use first non-service-desk type
                if (!selectedIssueType) {
                  const nonServiceDeskTypes = issueTypes.filter(it => 
                    !it.name.includes('Service') && 
                    !it.name.includes('Request') &&
                    !it.name.toLowerCase().includes('email')
                  );
                  selectedIssueType = nonServiceDeskTypes[0] || issueTypes[0];
                  console.log(`Using fallback issue type: ${selectedIssueType.name}`);
                }

                // Create Jira issue with GitHub issue number in summary for easier tracking
                const jiraResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/issue`, {
                  method: 'POST',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    fields: {
                      project: {
                        key: jiraConfig.projectKey
                      },
                      summary: `[GitHub] #${issue.number} - ${issue.title}`,
                      description: `${issue.body || 'No description provided'}\n\n---\n**GitHub Issue:** ${issue.html_url}`,
                      issuetype: {
                        id: selectedIssueType.id,
                        name: selectedIssueType.name
                      }
                    }
                  })
                });

                if (jiraResponse.ok) {
                  const jiraIssue = await jiraResponse.json();
                  console.log(`âœ… Created Jira issue: ${jiraIssue.key}`);
                  
                  // Now update the status based on GitHub issue state
                  await updateJiraIssueStatus(jiraIssue.key, issue, jiraConfig);
                  
                  console.log(`ðŸ”— Jira URL: https://${jiraConfig.host}/browse/${jiraIssue.key}`);
                  
                  // Try to add comment to GitHub issue
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `ðŸ”— Synced to Jira: https://${jiraConfig.host}/browse/${jiraIssue.key}`
                    });
                  } catch (commentError) {
                    console.log('âš ï¸ Could not add comment to GitHub issue, but Jira sync was successful');
                  }
                  
                  return jiraIssue;
                } else {
                  const errorText = await jiraResponse.text();
                  console.error('âŒ Jira API error:', jiraResponse.status, errorText);
                  
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `âŒ Failed to sync to Jira: ${jiraResponse.status} - ${errorText}`
                    });
                  } catch (commentError) {
                    console.log('âš ï¸ Could not add error comment to GitHub issue');
                  }
                }
              } catch (error) {
                console.error('âŒ Unexpected error:', error.message);
                
                try {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `âŒ Error syncing to Jira: ${error.message}`
                  });
                } catch (commentError) {
                  console.log('âš ï¸ Could not add error comment to GitHub issue');
                }
              }
            }

            async function findExistingJiraIssue(githubIssueNumber, jiraConfig) {
              try {
                const searchResponse = await fetch(`https://${jiraConfig.host}/rest/api/2/search?jql=project=RLM AND summary ~ "\\\\[GitHub\\\\] #${githubIssueNumber}"`, {
                  method: 'GET',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from(jiraConfig.email + ':' + jiraConfig.apiToken).toString('base64'),
                    'Content-Type': 'application/json',
                  },
                });

                if (searchResponse.ok) {
                  const searchResults = await searchResponse.json();
                  return searchResults.issues.length > 0 ? searchResults.issues[0] : null;
                }
              } catch (error) {
                console.error('Error searching for existing Jira issue:', error.message);
              }
              return null;
            }

            // ... (keep the existing updateTicketTypes function exactly as you had it before)
